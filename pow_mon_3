#!/usr/bin/env python3
"""
POWER MONITOR NODE - STAGE 3 FINAL (COMPLETE PRODUCTION VERSION)
Full-featured power monitor for fixed-wing aircraft with WIG effect awareness
- All Stage 1 & 2 features
- Current monitoring and averaging
- Time remaining calculations
- Return time estimation with safety margin
- WIG effect detection and efficiency tracking
- Loiter radius consideration
- Command retry logic
- State reset mechanisms
- Production logging
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy
from px4_msgs.msg import BatteryStatus, VehicleStatus, VehicleCommand, VehicleCommandAck, VehicleGlobalPosition
from std_msgs.msg import String
from threading import Lock
from collections import deque
import time
import math
import json

class PowerMonitorFinal(Node):
    def __init__(self):
        super().__init__('power_monitor_final')
        
        # Complete Parameters Set
        self.declare_parameter('rtl_battery_remaining', 30.0)
        self.declare_parameter('battery_check_interval', 5.0)
        self.declare_parameter('mission_start_grace_period', 30.0)
        self.declare_parameter('min_flight_time_before_rtl', 20.0)
        self.declare_parameter('home_position_timeout', 30.0)
        
        # NEW: Advanced parameters
        self.declare_parameter('safety_margin', 0.4)  # 40% safety margin for return
        self.declare_parameter('average_return_speed', 15.0)  # m/s cruise speed
        self.declare_parameter('battery_capacity_mah', 5000.0)
        self.declare_parameter('min_current_threshold', 0.1)
        self.declare_parameter('current_averaging_window', 10)
        self.declare_parameter('loiter_radius', 100.0)  # Fixed-wing loiter radius
        self.declare_parameter('rtl_reset_timeout', 60.0)
        self.declare_parameter('command_cooldown', 5.0)
        self.declare_parameter('max_command_retries', 3)
        
        # WIG Effect Parameters
        self.declare_parameter('wig_effect_altitude', 10.0)  # WIG effect below 10m
        self.declare_parameter('wig_efficiency_gain', 0.15)  # 15% efficiency in WIG
        self.declare_parameter('min_safe_altitude', 2.0)  # Minimum safe altitude
        
        self.declare_parameter('sitl_mode', True)
        self.declare_parameter('enable_rtl_trigger', True)
        
        # Get all parameters
        self.rtl_battery_remaining = self.get_parameter('rtl_battery_remaining').value
        self.check_interval = self.get_parameter('battery_check_interval').value
        self.mission_start_grace = self.get_parameter('mission_start_grace_period').value
        self.min_flight_time = self.get_parameter('min_flight_time_before_rtl').value
        self.home_timeout = self.get_parameter('home_position_timeout').value
        self.safety_margin = self.get_parameter('safety_margin').value
        self.return_speed = self.get_parameter('average_return_speed').value
        self.battery_capacity = self.get_parameter('battery_capacity_mah').value
        self.min_current = self.get_parameter('min_current_threshold').value
        self.current_window_size = self.get_parameter('current_averaging_window').value
        self.loiter_radius = self.get_parameter('loiter_radius').value
        self.rtl_reset_timeout = self.get_parameter('rtl_reset_timeout').value
        self.command_cooldown = self.get_parameter('command_cooldown').value
        self.max_retries = self.get_parameter('max_command_retries').value
        self.wig_altitude = self.get_parameter('wig_effect_altitude').value
        self.wig_efficiency = self.get_parameter('wig_efficiency_gain').value
        self.min_safe_alt = self.get_parameter('min_safe_altitude').value
        self.sitl_mode = self.get_parameter('sitl_mode').value
        self.enable_rtl = self.get_parameter('enable_rtl_trigger').value
        
        # Complete State Management
        self.battery_status = None
        self.vehicle_status = None
        self.global_position = None
        self.home_position = None
        self.rtl_triggered = False
        self.rtl_trigger_time = None
        self.rtl_completed = False
        self.lock = Lock()
        self.node_start_time = time.time()
        self.mission_start_time = None
        self.armed_time = None
        self.last_battery_log_time = 0
        self.battery_percentage = None
        self.last_valid_battery = None
        
        # Current monitoring
        self.current_history = deque(maxlen=self.current_window_size)
        self.sitl_default_current = 15.0
        
        # Command tracking
        self.last_command_time = 0
        self.pending_rtl_command = False
        self.command_retry_count = 0
        
        # WIG effect tracking
        self.in_wig_effect = False
        self.wig_time_total = 0
        self.wig_time_start = None
        self.efficiency_factor = 1.0
        
        # Mode tracking for debugging
        self.mode_history = deque(maxlen=10)
        self.previous_mode = None
        
        # QoS profile
        px4_qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
            durability=DurabilityPolicy.VOLATILE
        )
        
        # Publishers
        self.vehicle_command_pub = self.create_publisher(
            VehicleCommand,
            '/fmu/in/vehicle_command',
            px4_qos_profile
        )
        
        # NEW: Status publisher for monitoring
        self.status_pub = self.create_publisher(
            String,
            '/power_monitor/status',
            10
        )
        
        # Subscribers
        self.create_subscription(BatteryStatus, '/fmu/out/battery_status', 
                                self.battery_callback, qos_profile=px4_qos_profile)
        self.create_subscription(VehicleStatus, '/fmu/out/vehicle_status', 
                                self.status_callback, qos_profile=px4_qos_profile)
        self.create_subscription(VehicleCommandAck, '/fmu/out/vehicle_command_ack', 
                                self.command_ack_callback, qos_profile=px4_qos_profile)
        self.create_subscription(VehicleGlobalPosition, '/fmu/out/vehicle_global_position',
                                self.gps_callback, qos_profile=px4_qos_profile)
        
        # Main timer
        self.create_timer(self.check_interval, self.check_battery_status)
        
        # Status publisher timer (1Hz)
        self.create_timer(1.0, self.publish_status)
        
        # Startup message
        self.print_startup_info()
    
    def print_startup_info(self):
        """Print comprehensive startup information"""
        self.get_logger().info('='*60)
        self.get_logger().info('POWER MONITOR FINAL - PRODUCTION VERSION')
        self.get_logger().info('='*60)
        self.get_logger().info(f'‚úàÔ∏è Fixed-Wing Configuration:')
        self.get_logger().info(f'  ‚Ä¢ RTL Battery Threshold: {self.rtl_battery_remaining:.1f}%')
        self.get_logger().info(f'  ‚Ä¢ Return Speed: {self.return_speed:.1f} m/s')
        self.get_logger().info(f'  ‚Ä¢ Safety Margin: {self.safety_margin*100:.0f}%')
        self.get_logger().info(f'  ‚Ä¢ Loiter Radius: {self.loiter_radius:.0f}m')
        self.get_logger().info(f'üåä WIG Effect Parameters:')
        self.get_logger().info(f'  ‚Ä¢ WIG Altitude: < {self.wig_altitude:.1f}m')
        self.get_logger().info(f'  ‚Ä¢ Efficiency Gain: {self.wig_efficiency*100:.0f}%')
        self.get_logger().info(f'  ‚Ä¢ Min Safe Altitude: {self.min_safe_alt:.1f}m')
        self.get_logger().info(f'‚è±Ô∏è Grace Periods:')
        self.get_logger().info(f'  ‚Ä¢ Mission Start: {self.mission_start_grace:.0f}s')
        self.get_logger().info(f'  ‚Ä¢ Min Flight Time: {self.min_flight_time:.0f}s')
        self.get_logger().info('='*60)
    
    def battery_callback(self, msg):
        """Process battery with current monitoring"""
        with self.lock:
            self.battery_status = msg
            
            # Get battery percentage with validation
            if hasattr(msg, 'remaining'):
                new_percentage = None
                
                if 0 <= msg.remaining <= 1.0:
                    new_percentage = msg.remaining * 100.0
                elif 1.0 < msg.remaining <= 100.0:
                    new_percentage = msg.remaining
                
                if new_percentage is not None and 0 <= new_percentage <= 100:
                    self.battery_percentage = new_percentage
                    self.last_valid_battery = new_percentage
                elif self.last_valid_battery is not None:
                    self.battery_percentage = self.last_valid_battery
            
            # Track current for time remaining calculation
            if hasattr(msg, 'current_a'):
                current = msg.current_a if msg.current_a > 0 else self.sitl_default_current
                self.current_history.append(current)
    
    def gps_callback(self, msg):
        """Process GPS with WIG effect detection"""
        with self.lock:
            self.global_position = msg
            
            # Set home position on first valid GPS after arming
            if (self.home_position is None and 
                self.is_armed() and
                msg.lat != 0 and msg.lon != 0):
                
                self.home_position = (msg.lat, msg.lon, msg.alt)
                self.get_logger().info(f'üè† Home position set: lat={msg.lat:.6f}, lon={msg.lon:.6f}, alt={msg.alt:.2f}m')
            
            # WIG effect detection based on altitude
            if self.is_armed() and hasattr(msg, 'alt'):
                altitude_agl = self.get_altitude_agl()
                
                if altitude_agl is not None:
                    was_in_wig = self.in_wig_effect
                    self.in_wig_effect = (altitude_agl <= self.wig_altitude and 
                                         altitude_agl >= self.min_safe_alt)
                    
                    # Track WIG time
                    if self.in_wig_effect and not was_in_wig:
                        self.wig_time_start = time.time()
                        self.get_logger().info(f'üåä Entered WIG effect zone (alt: {altitude_agl:.1f}m)')
                    elif not self.in_wig_effect and was_in_wig:
                        if self.wig_time_start:
                            self.wig_time_total += time.time() - self.wig_time_start
                        self.get_logger().info(f'‚òÅÔ∏è Exited WIG effect zone (alt: {altitude_agl:.1f}m)')
                    
                    # Update efficiency factor
                    self.efficiency_factor = 1.0 + self.wig_efficiency if self.in_wig_effect else 1.0
    
    def status_callback(self, msg):
        """Process vehicle status with complete state tracking"""
        with self.lock:
            previous_mode = self.get_current_mode() if self.vehicle_status else None
            previous_arming = self.vehicle_status.arming_state if self.vehicle_status else None
            
            self.vehicle_status = msg
            current_mode = self.get_current_mode()
            
            # Track mode changes for debugging
            if previous_mode != current_mode:
                self.mode_history.append((time.time(), previous_mode, current_mode))
                self.get_logger().info(f'‚úàÔ∏è Mode: {previous_mode} ‚Üí {current_mode}')
                
                # Mission start detection
                if current_mode in ['AUTO.MISSION', 'AUTO.TAKEOFF'] and \
                   previous_mode not in ['AUTO.MISSION', 'AUTO.TAKEOFF', 'AUTO.LOITER']:
                    self.mission_start_time = time.time()
                    self.get_logger().info(f'üöÄ Mission started - Grace period: {self.mission_start_grace}s')
                
                # RTL completion detection
                if previous_mode == 'AUTO.RTL':
                    if current_mode == 'AUTO.LOITER':
                        self.handle_rtl_completion('LOITER')
                    elif current_mode in ['AUTO.LAND', 'MANUAL']:
                        self.handle_rtl_completion('LAND')
                
                # Mission resume detection
                if self.rtl_triggered and current_mode in ['AUTO.MISSION']:
                    self.handle_mission_resume()
            
            # Track arming
            if previous_arming != msg.arming_state:
                if msg.arming_state == 2:  # ARMED
                    self.handle_arm()
                elif msg.arming_state == 1:  # DISARMED
                    self.handle_disarm()
            
            self.previous_mode = current_mode
    
    def command_ack_callback(self, msg):
        """Process command acknowledgments with retry logic"""
        with self.lock:
            if self.pending_rtl_command:
                if msg.command == VehicleCommand.VEHICLE_CMD_NAV_RETURN_TO_LAUNCH:
                    if msg.result == VehicleCommandAck.VEHICLE_CMD_RESULT_ACCEPTED:
                        self.get_logger().info('‚úÖ RTL command ACCEPTED by PX4')
                        self.rtl_triggered = True
                        self.rtl_trigger_time = time.time()
                        self.pending_rtl_command = False
                        self.command_retry_count = 0
                    elif msg.result == VehicleCommandAck.VEHICLE_CMD_RESULT_TEMPORARILY_REJECTED:
                        self.get_logger().warn(f'‚è≥ RTL command TEMPORARILY REJECTED (retry {self.command_retry_count}/{self.max_retries})')
                        self.pending_rtl_command = False
                        # Will retry on next check
                    else:
                        self.get_logger().error(f'‚ùå RTL command FAILED: result={msg.result}')
                        self.command_retry_count += 1
                        self.pending_rtl_command = False
                        
                        if self.command_retry_count >= self.max_retries:
                            self.get_logger().error('‚ùå Max RTL retries reached - giving up')
                            self.rtl_triggered = True  # Prevent spam
    
    def get_current_mode(self):
        """Get current flight mode with extended mapping"""
        if not self.vehicle_status:
            return "UNKNOWN"
        
        mode_map = {
            0: "MANUAL", 1: "ALTITUDE", 2: "POSITION", 3: "AUTO.LOITER",
            4: "AUTO.MISSION", 5: "AUTO.RTL", 6: "AUTO.LAND", 7: "AUTO.TAKEOFF",
            8: "OFFBOARD", 9: "STABILIZED", 10: "ACRO", 11: "AUTO.LAND_ENGAGED",
            12: "AUTO.PRECLAND", 13: "ORBIT", 14: "AUTO.VTOL_TAKEOFF"
        }
        
        return mode_map.get(self.vehicle_status.nav_state, f"MODE_{self.vehicle_status.nav_state}")
    
    def is_armed(self):
        if self.vehicle_status:
            return self.vehicle_status.arming_state == 2
        return False
    
    def is_failsafe_active(self):
        if self.vehicle_status:
            return self.vehicle_status.failsafe
        return False
    
    def get_flight_time(self):
        if self.armed_time is None:
            return 0
        return time.time() - self.armed_time
    
    def get_altitude_agl(self):
        """Get altitude above ground level"""
        if self.global_position and self.home_position:
            return self.global_position.alt - self.home_position[2]
        return None
    
    def is_in_grace_period(self):
        """Check if in any grace period"""
        current_time = time.time()
        
        # Mission start grace
        if self.mission_start_time is not None:
            time_since_mission = current_time - self.mission_start_time
            if time_since_mission < self.mission_start_grace:
                remaining = self.mission_start_grace - time_since_mission
                self.get_logger().info(f'‚è≥ Mission grace: {remaining:.1f}s remaining')
                return True
        
        # Min flight time
        flight_time = self.get_flight_time()
        if flight_time > 0 and flight_time < self.min_flight_time:
            remaining = self.min_flight_time - flight_time
            self.get_logger().info(f'‚è≥ Min flight time: {remaining:.1f}s remaining')
            return True
            
        return False
    
    def calculate_distance_to_home(self):
        """Calculate distance with altitude consideration"""
        if self.home_position is None or self.global_position is None:
            return None
        
        lat1, lon1, alt1 = self.home_position
        lat2 = self.global_position.lat
        lon2 = self.global_position.lon
        alt2 = self.global_position.alt
        
        # Haversine formula
        R = 6371000
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        delta_phi = math.radians(lat2 - lat1)
        delta_lambda = math.radians(lon2 - lon1)
        
        a = math.sin(delta_phi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        horizontal = R * c
        vertical = abs(alt2 - alt1) * 0.3  # Reduced weight for fixed-wing
        
        return horizontal + vertical
    
    def get_average_current(self):
        """Get average current draw"""
        if not self.current_history:
            return self.sitl_default_current if self.sitl_mode else None
        return sum(self.current_history) / len(self.current_history)
    
    def calculate_remaining_time(self):
        """Calculate battery time remaining with WIG efficiency"""
        if self.battery_percentage is None:
            return None
        
        avg_current = self.get_average_current()
        if avg_current is None or avg_current < self.min_current:
            return None
        
        # Adjust for WIG efficiency
        effective_current = avg_current / self.efficiency_factor
        
        capacity = self.battery_capacity
        if hasattr(self.battery_status, 'capacity') and self.battery_status.capacity > 0:
            capacity = self.battery_status.capacity
        
        remaining_mah = (self.battery_percentage / 100.0) * capacity
        current_draw_ma = effective_current * 1000.0
        
        if current_draw_ma > 0:
            time_hours = remaining_mah / current_draw_ma
            return time_hours * 3600.0
        return None
    
    def calculate_return_time(self):
        """Calculate time needed to return with loiter consideration"""
        distance = self.calculate_distance_to_home()
        if distance is None:
            return None
        
        # Base return time
        base_time = distance / self.return_speed
        
        # Add loiter pattern time (one circle)
        loiter_time = (2 * math.pi * self.loiter_radius) / self.return_speed
        
        # Apply safety margin
        total_time = (base_time + loiter_time) * (1 + self.safety_margin)
        
        # Add fixed buffer
        return total_time + 120  # 2 minutes extra
    
    def send_rtl_command(self):
        """Send RTL command with retry tracking"""
        if time.time() - self.last_command_time < self.command_cooldown:
            return False
        
        self.get_logger().warn('üö® SENDING RTL COMMAND')
        
        msg = VehicleCommand()
        msg.timestamp = int(self.get_clock().now().nanoseconds / 1000)
        msg.command = VehicleCommand.VEHICLE_CMD_NAV_RETURN_TO_LAUNCH
        msg.param1 = 0.0
        msg.param2 = 0.0
        msg.param3 = 0.0
        msg.param4 = 0.0
        msg.param5 = 0.0
        msg.param6 = 0.0
        msg.param7 = 0.0
        msg.target_system = 1
        msg.target_component = 1
        msg.source_system = 1
        msg.source_component = 1
        msg.from_external = True
        
        self.vehicle_command_pub.publish(msg)
        self.pending_rtl_command = True
        self.last_command_time = time.time()
        return True
    
    def handle_arm(self):
        """Handle arming event"""
        self.armed_time = time.time()
        self.reset_rtl_state("Vehicle armed")
        self.wig_time_total = 0
        self.get_logger().info('‚úàÔ∏è Vehicle ARMED - Power monitor active')
    
    def handle_disarm(self):
        """Handle disarm event"""
        # Log WIG statistics
        if self.wig_time_total > 0:
            self.get_logger().info(f'üåä WIG Effect Summary: {self.wig_time_total:.1f}s total')
            efficiency_saved = self.wig_time_total * self.wig_efficiency
            self.get_logger().info(f'üí° Estimated efficiency gain: {efficiency_saved:.1f}s flight time')
        
        self.armed_time = None
        self.mission_start_time = None
        self.home_position = None
        self.rtl_triggered = False
        self.get_logger().info('üõë Vehicle DISARMED')
    
    def handle_rtl_completion(self, end_mode):
        """Handle RTL completion"""
        self.get_logger().info(f'‚úÖ RTL completed ‚Üí {end_mode}')
        self.rtl_completed = True
        
        if end_mode == 'LOITER':
            self.get_logger().info(f'‚úàÔ∏è Loitering at home (radius: {self.loiter_radius}m)')
    
    def handle_mission_resume(self):
        """Handle mission resume after RTL"""
        self.get_logger().info('üìç Mission resumed after RTL')
        self.reset_rtl_state("Mission resumed")
        self.mission_start_time = time.time()  # Reset grace
    
    def reset_rtl_state(self, reason):
        """Reset RTL state"""
        if self.rtl_triggered:
            self.get_logger().info(f'üîÑ Resetting RTL state: {reason}')
        self.rtl_triggered = False
        self.rtl_trigger_time = None
        self.rtl_completed = False
        self.command_retry_count = 0
        self.pending_rtl_command = False
    
    def publish_status(self):
        """Publish comprehensive status for monitoring"""
        with self.lock:
            status = {
                'timestamp': time.time(),
                'battery_pct': self.battery_percentage,
                'current_avg': self.get_average_current(),
                'time_remaining': self.calculate_remaining_time(),
                'distance_home': self.calculate_distance_to_home(),
                'return_time': self.calculate_return_time(),
                'mode': self.get_current_mode(),
                'armed': self.is_armed(),
                'rtl_triggered': self.rtl_triggered,
                'in_wig_effect': self.in_wig_effect,
                'altitude_agl': self.get_altitude_agl(),
                'efficiency_factor': self.efficiency_factor,
                'flight_time': self.get_flight_time()
            }
            
            msg = String()
            msg.data = json.dumps(status)
            self.status_pub.publish(msg)
    
    def check_battery_status(self):
        """Main battery checking logic - Complete version"""
        with self.lock:
            # Skip if not armed
            if not self.is_armed():
                return
            
            # Skip if RTL already triggered (unless timeout)
            if self.rtl_triggered:
                if self.rtl_trigger_time:
                    elapsed = time.time() - self.rtl_trigger_time
                    if elapsed > self.rtl_reset_timeout:
                        current_mode = self.get_current_mode()
                        if current_mode not in ['AUTO.RTL', 'AUTO.LOITER', 'AUTO.LAND']:
                            self.reset_rtl_state(f"RTL timeout ({elapsed:.0f}s)")
                    else:
                        return
                else:
                    return
            
            # Skip if in grace period
            if self.is_in_grace_period():
                return
            
            # Skip if failsafe active
            if self.is_failsafe_active():
                self.get_logger().debug('PX4 failsafe active - standing by')
                return
            
            # Skip if already in safe mode
            current_mode = self.get_current_mode()
            if current_mode in ['AUTO.RTL', 'AUTO.LAND', 'MANUAL', 'AUTO.LAND_ENGAGED']:
                return
            
            # Check prerequisites
            if self.battery_percentage is None:
                return
            
            if self.home_position is None:
                elapsed = time.time() - self.node_start_time
                if elapsed > self.home_timeout:
                    self.get_logger().warn(f'‚ö†Ô∏è No home position after {self.home_timeout}s')
                return
            
            # Calculate all metrics
            distance = self.calculate_distance_to_home()
            remaining_time = self.calculate_remaining_time()
            return_time = self.calculate_return_time()
            altitude = self.get_altitude_agl()
            avg_current = self.get_average_current()
            
            # Build comprehensive log
            log_parts = [
                f'üîã Battery: {self.battery_percentage:.1f}%',
                f'üìç Mode: {current_mode}'
            ]
            
            if distance:
                log_parts.append(f'üè† Distance: {distance:.1f}m')
            
            if remaining_time:
                log_parts.append(f'‚è±Ô∏è Time left: {remaining_time/60:.1f}min')
            
            if return_time:
                log_parts.append(f'üîÅ RTL needs: {return_time/60:.1f}min')
            
            if altitude:
                log_parts.append(f'üìè Alt: {altitude:.1f}m')
                if self.in_wig_effect:
                    log_parts.append('üåä WIG ACTIVE')
            
            if avg_current:
                log_parts.append(f'‚ö° Current: {avg_current:.1f}A')
            
            self.get_logger().info(' | '.join(log_parts))
            
            # Check RTL conditions
            should_rtl = False
            reason = ""
            
            # Battery threshold check
            if self.battery_percentage <= self.rtl_battery_remaining:
                should_rtl = True
                reason = f"battery at threshold ({self.battery_percentage:.1f}% ‚â§ {self.rtl_battery_remaining:.1f}%)"
            
            # Time remaining check
            elif remaining_time and return_time and remaining_time < return_time:
                should_rtl = True
                reason = f"insufficient time ({remaining_time/60:.1f}min < {return_time/60:.1f}min needed)"
            
            # Trigger RTL if needed
            if should_rtl and self.command_retry_count < self.max_retries:
                self.get_logger().warn(f'‚ö†Ô∏è RTL NEEDED: {reason}')
                if self.enable_rtl:
                    if self.send_rtl_command():
                        self.command_retry_count += 1
                else:
                    self.get_logger().info('RTL trigger disabled for testing')

def main(args=None):
    rclpy.init(args=args)
    node = PowerMonitorFinal()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info('Shutting down Power Monitor Final')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
