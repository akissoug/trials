#!/usr/bin/env python3
"""
POWER MONITOR NODE - COMPLETE VERSION FOR FIXED-WING
Optimized for fixed-wing aircraft operating in WIG effect
Uses direct RTL command instead of mode change
"""

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy
from px4_msgs.msg import BatteryStatus, VehicleGlobalPosition, VehicleStatus, VehicleCommand, VehicleCommandAck
import math
from threading import Lock
from collections import deque
import time

class PowerMonitor(Node):
    def __init__(self):
        super().__init__('power_monitor')

        # Parameters - optimized for fixed-wing
        self.declare_parameter('safety_margin', 0.4)  # Higher margin for fixed-wing
        self.declare_parameter('average_return_speed', 15.0)  # Fixed-wing cruise speed
        self.declare_parameter('battery_check_interval', 5.0)
        self.declare_parameter('min_battery_voltage', 14.0)
        self.declare_parameter('rtl_battery_remaining', 30.0)  # Higher for fixed-wing (30%)
        self.declare_parameter('battery_capacity_mah', 5000.0)
        self.declare_parameter('min_current_threshold', 0.1)
        self.declare_parameter('current_averaging_window', 10)
        self.declare_parameter('home_position_timeout', 30.0)
        self.declare_parameter('sitl_mode', True)
        self.declare_parameter('command_cooldown', 5.0)
        self.declare_parameter('rtl_reset_timeout', 60.0)  # Longer for fixed-wing
        self.declare_parameter('mission_start_grace_period', 30.0)
        self.declare_parameter('min_flight_time_before_rtl', 20.0)  # Longer for fixed-wing
        self.declare_parameter('loiter_radius', 100.0)  # Fixed-wing loiter radius at home

        self.safety_margin = self.get_parameter('safety_margin').value
        self.return_speed = self.get_parameter('average_return_speed').value
        self.check_interval = self.get_parameter('battery_check_interval').value
        self.rtl_battery_remaining = self.get_parameter('rtl_battery_remaining').value
        self.battery_capacity = self.get_parameter('battery_capacity_mah').value
        self.min_current = self.get_parameter('min_current_threshold').value
        self.current_window_size = self.get_parameter('current_averaging_window').value
        self.home_timeout = self.get_parameter('home_position_timeout').value
        self.sitl_mode = self.get_parameter('sitl_mode').value
        self.command_cooldown = self.get_parameter('command_cooldown').value
        self.rtl_reset_timeout = self.get_parameter('rtl_reset_timeout').value
        self.mission_start_grace = self.get_parameter('mission_start_grace_period').value
        self.min_flight_time = self.get_parameter('min_flight_time_before_rtl').value
        self.loiter_radius = self.get_parameter('loiter_radius').value

        # State
        self.battery_status = None
        self.global_position = None
        self.home_position = None
        self.vehicle_status = None
        self.rtl_triggered = False
        self.rtl_trigger_time = None
        self.rtl_completed = False
        self.previous_mode = None
        self.lock = Lock()
        self.start_time = time.time()
        self.mission_start_time = None
        self.armed_time = None
        self.last_command_result = None
        self.command_retry_count = 0
        self.max_command_retries = 3
        self.last_command_time = 0
        self.failsafe_notified = False
        self.pending_command_timestamp = None
        self.last_rtl_command_type = None  # Track which RTL command we sent
        
        # Current averaging
        self.current_history = deque(maxlen=self.current_window_size)
        self.sitl_default_current = 15.0  # Higher for fixed-wing
        
        # Data validation
        self.last_valid_battery = None
        self.battery_reading_count = 0

        # Define QoS profile
        px4_qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=1,
            durability=DurabilityPolicy.VOLATILE
        )

        # Publishers
        self.vehicle_command_pub = self.create_publisher(
            VehicleCommand,
            '/fmu/in/vehicle_command',
            px4_qos_profile
        )

        # Subscribers
        self.create_subscription(BatteryStatus, '/fmu/out/battery_status', self.battery_callback, qos_profile=px4_qos_profile)
        self.create_subscription(VehicleGlobalPosition, '/fmu/out/vehicle_global_position', self.gps_callback, qos_profile=px4_qos_profile)
        self.create_subscription(VehicleStatus, '/fmu/out/vehicle_status', self.status_callback, qos_profile=px4_qos_profile)
        self.create_subscription(VehicleCommandAck, '/fmu/out/vehicle_command_ack', self.command_ack_callback, qos_profile=px4_qos_profile)

        # Periodic check
        self.create_timer(self.check_interval, self.check_battery_status)

        self.get_logger().info('âœ… PowerMonitor node initialized (FIXED-WING VERSION)')
        self.get_logger().info(f'âœˆï¸ Fixed-wing configuration loaded')
        self.get_logger().info(f'ğŸ”‹ RTL when battery remaining: {self.rtl_battery_remaining:.1f}%')
        self.get_logger().info(f'â±ï¸ Grace period: {self.mission_start_grace}s after mission start')
        self.get_logger().info(f'ğŸ”„ Loiter radius at home: {self.loiter_radius}m')
        if self.sitl_mode:
            self.get_logger().info('ğŸ® Running in SITL mode')

    def battery_callback(self, msg):
        with self.lock:
            self.battery_status = msg
            current = msg.current_a if msg.current_a > 0 else self.sitl_default_current
            self.current_history.append(current)
            
            # Validate and log battery reading
            battery_pct = self.get_battery_percentage()
            if battery_pct is not None:
                self.battery_reading_count += 1
                # Only log every 10th reading to reduce spam
                if self.battery_reading_count % 10 == 0:
                    self.get_logger().debug(f'Battery: {battery_pct:.1f}%, Current: {current:.1f}A')
                
                # Track valid readings
                if 0 <= battery_pct <= 100:
                    self.last_valid_battery = battery_pct

    def gps_callback(self, msg):
        with self.lock:
            self.global_position = msg
            
            # Only set home position with good GPS fix (important for fixed-wing)
            if (self.home_position is None and 
                not msg.dead_reckoning and 
                msg.fix_type >= 3 and
                msg.satellites_used >= 8 and  # Higher requirement for fixed-wing
                abs(msg.lat) > 0.001 and abs(msg.lon) > 0.001 and
                abs(msg.lat) <= 90.0 and abs(msg.lon) <= 180.0):
                
                self.home_position = (msg.lat, msg.lon, msg.alt)
                self.get_logger().info(f'ğŸ  Home position set: lat={msg.lat:.6f}, lon={msg.lon:.6f}, alt={msg.alt:.2f}m')
                self.get_logger().info(f'âœˆï¸ Fixed-wing will loiter at {self.loiter_radius}m radius around home')

    def status_callback(self, msg):
        with self.lock:
            previous_arming = self.vehicle_status.arming_state if self.vehicle_status else None
            previous_mode = self.get_current_mode() if self.vehicle_status else None
            
            self.vehicle_status = msg
            current_mode = self.get_current_mode()
            
            # Track arming time
            if previous_arming != msg.arming_state:
                if msg.arming_state == 2:  # ARMED
                    self.armed_time = time.time()
                    self.reset_rtl_state("Vehicle armed")
                    self.get_logger().info('âœˆï¸ Fixed-wing armed')
                elif msg.arming_state == 1:  # DISARMED
                    self.armed_time = None
                    self.mission_start_time = None
                    self.get_logger().info('ğŸ›‘ Fixed-wing disarmed')
            
            # Track mode changes
            if previous_mode != current_mode:
                self.get_logger().info(f'Mode: {previous_mode} â†’ {current_mode}')
                
                # Track mission start
                if current_mode in ['AUTO.MISSION', 'AUTO.TAKEOFF'] and previous_mode not in ['AUTO.MISSION', 'AUTO.TAKEOFF']:
                    self.mission_start_time = time.time()
                    self.get_logger().info(f'ğŸš€ Mission started - grace period active for {self.mission_start_grace}s')
                
                # Handle RTL completion (fixed-wing will loiter at home)
                if previous_mode == 'AUTO.RTL' and current_mode == 'AUTO.LOITER':
                    self.handle_rtl_completion(current_mode)
                
                # Handle mission resume
                if self.rtl_triggered and current_mode in ['AUTO.MISSION']:
                    self.handle_mission_resume()
            
            self.previous_mode = current_mode
            
            # Check failsafe
            if msg.failsafe and not self.failsafe_notified:
                self.get_logger().info('âš ï¸ PX4 failsafe active')
                self.failsafe_notified = True
            elif not msg.failsafe and self.failsafe_notified:
                self.get_logger().info('âœ… PX4 failsafe cleared')
                self.failsafe_notified = False

    def command_ack_callback(self, msg):
        with self.lock:
            # Check if this is an acknowledgment for our RTL command
            if self.pending_command_timestamp is not None:
                time_since_command = time.time() - self.last_command_time
                
                # Check for both RTL command types
                if ((msg.command == VehicleCommand.VEHICLE_CMD_NAV_RETURN_TO_LAUNCH or
                     msg.command == VehicleCommand.VEHICLE_CMD_DO_SET_MODE) and 
                    time_since_command < 2.0):
                    
                    if msg.result == VehicleCommandAck.VEHICLE_CMD_RESULT_ACCEPTED:
                        self.get_logger().info('âœ… Power monitor RTL command accepted by PX4')
                        self.rtl_triggered = True
                        self.rtl_trigger_time = time.time()
                        self.pending_command_timestamp = None
                        self.command_retry_count = 0
                    elif msg.result == VehicleCommandAck.VEHICLE_CMD_RESULT_TEMPORARILY_REJECTED:
                        self.get_logger().warn('â³ Power monitor RTL temporarily rejected - will retry')
                        self.pending_command_timestamp = None
                    else:
                        self.get_logger().error(f'âŒ Power monitor RTL failed: result={msg.result}')
                        self.command_retry_count += 1
                        self.pending_command_timestamp = None

    def get_current_mode(self):
        if not self.vehicle_status:
            return "UNKNOWN"
        
        mode_map = {
            0: "MANUAL", 1: "ALTITUDE", 2: "POSITION", 3: "AUTO.LOITER",
            4: "AUTO.MISSION", 5: "AUTO.RTL", 6: "AUTO.LAND", 7: "AUTO.TAKEOFF",
            8: "OFFBOARD", 9: "STABILIZED", 10: "ACRO", 11: "AUTO.LAND_ENGAGED",
            12: "AUTO.PRECLAND", 13: "ORBIT", 14: "AUTO.VTOL_TAKEOFF"
        }
        
        return mode_map.get(self.vehicle_status.nav_state, f"UNKNOWN({self.vehicle_status.nav_state})")

    def is_armed(self):
        if self.vehicle_status:
            return self.vehicle_status.arming_state == 2
        return False

    def is_failsafe_active(self):
        if self.vehicle_status:
            return self.vehicle_status.failsafe
        return False

    def get_battery_percentage(self):
        """Get battery percentage with validation"""
        if self.battery_status is None:
            return None
            
        if hasattr(self.battery_status, 'remaining'):
            remaining = self.battery_status.remaining
            
            # Handle both 0-1 and 0-100 scales
            if 0 <= remaining <= 1.0:
                return remaining * 100.0
            elif 1.0 < remaining <= 100.0:
                return remaining
            else:
                self.get_logger().warn(f'Invalid battery remaining: {remaining}')
                return self.last_valid_battery
        return None

    def get_flight_time(self):
        """Get time since arming"""
        if self.armed_time is None:
            return 0
        return time.time() - self.armed_time

    def is_in_grace_period(self):
        """Check if we're in any grace period"""
        # Mission start grace period
        if self.mission_start_time is not None:
            if (time.time() - self.mission_start_time) < self.mission_start_grace:
                return True
        
        # Minimum flight time grace period
        if self.get_flight_time() < self.min_flight_time:
            return True
            
        return False

    def send_rtl_command(self):
        """Send direct RTL command (recommended for fixed-wing)"""
        current_time = time.time()
        
        # Check cooldown
        if current_time - self.last_command_time < self.command_cooldown:
            self.get_logger().debug('Command cooldown active')
            return False
        
        # Create unique timestamp for this command
        self.pending_command_timestamp = int(current_time * 1000)
        
        msg = VehicleCommand()
        msg.timestamp = int(self.get_clock().now().nanoseconds / 1000)
        msg.command = VehicleCommand.VEHICLE_CMD_NAV_RETURN_TO_LAUNCH
        msg.param1 = 0.0  # No parameters needed for direct RTL
        msg.param2 = 0.0
        msg.param3 = 0.0
        msg.param4 = 0.0
        msg.param5 = 0.0
        msg.param6 = 0.0
        msg.param7 = 0.0
        msg.target_system = 1
        msg.target_component = 1
        msg.source_system = 1
        msg.source_component = 1
        msg.from_external = True
        
        self.vehicle_command_pub.publish(msg)
        self.last_command_time = current_time
        self.last_rtl_command_type = 'NAV_RTL'
        return True

    def calculate_remaining_time(self):
        battery_percentage = self.get_battery_percentage()
        if battery_percentage is None:
            return None

        avg_current = self.get_average_current()
        if avg_current is None or avg_current < self.min_current:
            return None

        capacity = self.battery_capacity
        if hasattr(self.battery_status, 'capacity') and self.battery_status.capacity > 0:
            capacity = self.battery_status.capacity

        remaining_mah = (battery_percentage / 100.0) * capacity
        current_draw_ma = avg_current * 1000.0
        
        if current_draw_ma > 0:
            time_hours = remaining_mah / current_draw_ma
            return time_hours * 3600.0
        return None

    def get_average_current(self):
        if not self.current_history:
            return self.sitl_default_current if self.sitl_mode else None
        return sum(self.current_history) / len(self.current_history)

    def haversine_distance(self, lat1, lon1, lat2, lon2):
        R = 6371000
        phi1, phi2 = math.radians(lat1), math.radians(lat2)
        d_phi = math.radians(lat2 - lat1)
        d_lambda = math.radians(lon2 - lon1)
        a = math.sin(d_phi / 2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(d_lambda / 2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        return R * c

    def calculate_distance_to_home(self):
        if self.home_position is None or self.global_position is None:
            return None
        
        lat1, lon1, alt1 = self.home_position
        lat2, lon2, alt2 = self.global_position.lat, self.global_position.lon, self.global_position.alt
        
        # Validate coordinates
        if abs(lat2) > 90.0 or abs(lon2) > 180.0:
            return None
            
        horizontal = self.haversine_distance(lat1, lon1, lat2, lon2)
        # For fixed-wing, altitude difference is less critical due to gliding capability
        vertical = abs(alt2 - alt1) * 0.3  # Reduced weight for altitude
        return horizontal + vertical

    def check_battery_status(self):
        with self.lock:
            # Skip if in grace period
            if self.is_in_grace_period():
                if self.mission_start_time:
                    elapsed = time.time() - self.mission_start_time
                    self.get_logger().debug(f'Grace period: {elapsed:.1f}/{self.mission_start_grace}s')
                else:
                    flight_time = self.get_flight_time()
                    self.get_logger().debug(f'Min flight time: {flight_time:.1f}/{self.min_flight_time}s')
                return
            
            # Check RTL timeout
            if self.rtl_triggered and self.rtl_trigger_time:
                elapsed = time.time() - self.rtl_trigger_time
                if elapsed > self.rtl_reset_timeout:
                    current_mode = self.get_current_mode()
                    # Fixed-wing may loiter at home after RTL
                    if current_mode not in ['AUTO.RTL', 'AUTO.LOITER', 'AUTO.LAND']:
                        self.reset_rtl_state(f"RTL timeout ({elapsed:.0f}s)")
            
            # Skip if RTL already triggered
            if self.rtl_triggered:
                return

            # Skip if failsafe active
            if self.is_failsafe_active():
                return

            # Check prerequisites
            if self.home_position is None:
                return

            current_mode = self.get_current_mode()
            if current_mode in ['AUTO.RTL', 'AUTO.LAND', 'MANUAL', 'AUTO.LAND_ENGAGED']:
                return

            if not all([self.battery_status, self.global_position]):
                return

            battery_percentage = self.get_battery_percentage()
            if battery_percentage is None:
                return

            # Validate battery reading
            if battery_percentage > 100.0 or battery_percentage < 0.0:
                self.get_logger().error(f'Invalid battery: {battery_percentage}%')
                return

            remaining_time = self.calculate_remaining_time()
            distance = self.calculate_distance_to_home()

            if distance is None:
                return

            # Calculate return time (including loiter time for fixed-wing)
            base_return_time = distance / self.return_speed
            # Add time for approach and loiter pattern
            approach_time = (2 * math.pi * self.loiter_radius) / self.return_speed
            safety_return_time = (base_return_time + approach_time) * (1 + self.safety_margin) + 120.0  # 2 min extra

            # Log status
            log_msg = f'âœˆï¸ Battery: {battery_percentage:.1f}%, '
            log_msg += f'ğŸ  Distance: {distance:.1f}m, '
            if remaining_time:
                log_msg += f'â³ Time left: {remaining_time:.1f}s, '
            log_msg += f'ğŸ” RTL needs: {safety_return_time:.1f}s'
            
            self.get_logger().info(log_msg)

            # Check RTL conditions
            should_rtl = False
            reason = ""
            
            # Check battery threshold (remaining percentage)
            if battery_percentage <= self.rtl_battery_remaining:
                should_rtl = True
                reason = f"battery at threshold ({battery_percentage:.1f}% â‰¤ {self.rtl_battery_remaining:.1f}%)"
            
            # Check time remaining
            elif remaining_time is not None and remaining_time < safety_return_time:
                should_rtl = True
                reason = f"insufficient time ({remaining_time:.1f}s < {safety_return_time:.1f}s)"
            
            if should_rtl and self.command_retry_count < self.max_command_retries:
                self.trigger_rtl(reason)

    def trigger_rtl(self, reason):
        if self.rtl_triggered:
            return
        
        self.get_logger().warn(f'âš ï¸ POWER MONITOR triggering RTL: {reason}')
        
        if self.send_rtl_command():
            self.get_logger().info('ğŸ“¡ Direct RTL command sent by power monitor')

    def handle_rtl_completion(self, new_mode):
        self.get_logger().info(f'RTL completed â†’ {new_mode} (fixed-wing loitering at home)')
        self.rtl_completed = True
        
        # For fixed-wing, loitering at home is normal after RTL
        if new_mode in ['AUTO.LOITER']:
            self.get_logger().info(f'âœˆï¸ Fixed-wing loitering at {self.loiter_radius}m radius')

    def handle_mission_resume(self):
        self.get_logger().info('Mission resumed after RTL')
        self.reset_rtl_state("Mission resumed")
        self.mission_start_time = time.time()  # Reset grace period

    def reset_rtl_state(self, reason):
        if self.rtl_triggered:
            self.get_logger().info(f'Resetting RTL state: {reason}')
        self.rtl_triggered = False
        self.rtl_trigger_time = None
        self.rtl_completed = False
        self.command_retry_count = 0
        self.pending_command_timestamp = None

def main(args=None):
    rclpy.init(args=args)
    node = PowerMonitor()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
